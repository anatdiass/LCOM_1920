#include <lcom/lcf.h>
#include <lcom/timer.h>

#include <stdint.h>

#include "i8254.h"

int(timer_set_frequency)(uint8_t timer, uint32_t freq) {

  uint32_t div = TIMER_FREQ / freq;
  uint8_t lsb, msb;
  util_get_LSB((uint16_t)(div), &lsb);
  util_get_MSB((uint16_t)(div), &msb);
  /*uint32_t control = TIMER_SQR_WAVE|TIMER_LSB_MSB|TIMER_BCD|(TIMER_SEL0 + timer);

  printf("aqui\n" );


  if (sys_outb(TIMER_CTRL, control) != OK)
    return 1;

  if(util_get_LSB(TIMER_0+timer,div))*/

  if(timer == 0){
    sys_outb(TIMER_CTRL,(TIMER_SQR_WAVE|TIMER_LSB_MSB|TIMER_BCD|TIMER_SEL0));
    sys_outb(TIMER_0,lsb);
    sys_outb(TIMER_0,msb);

    printf("aqui1\n" );
  }
  else if(timer == 1){
    sys_outb(TIMER_CTRL,(TIMER_SQR_WAVE|TIMER_LSB_MSB|TIMER_BCD|TIMER_SEL1));
    sys_outb(TIMER_1,lsb);
    sys_outb(TIMER_1,msb);
    printf("aqui2\n" );

  }
  else if(timer == 2){
    sys_outb(TIMER_CTRL,(TIMER_SQR_WAVE|TIMER_LSB_MSB|TIMER_BCD|TIMER_SEL2));
    sys_outb(TIMER_2,lsb);
    sys_outb(TIMER_2,msb);
    printf("aqui3\n" );

  }
  else return 1;

  printf("aqui4\n" );
  return 0;
}

int(timer_subscribe_int)(uint8_t *bit_no) {
  /* To be implemented by the students */
  printf("%s is not yet implemented!\n", __func__);

  return 1;
}

int(timer_unsubscribe_int)() {
  /* To be implemented by the students */
  printf("%s is not yet implemented!\n", __func__);

  return 1;
}

void(timer_int_handler)() {
  /* To be implemented by the students */
  printf("%s is not yet implemented!\n", __func__);
}

int(timer_get_conf)(uint8_t timer, uint8_t *st) {

  if (timer != 0 && timer != 1 && timer != 2)
    return 1;

  uint8_t read_rb; //variable used to store read configuration

  read_rb = TIMER_RB_CMD | TIMER_RB_SEL(timer) | TIMER_RB_COUNT_;

  //writes to the control register
  if (sys_outb(TIMER_CTRL, read_rb) != OK)
    return 1;


  if (util_sys_inb(TIMER_0 + timer, st ) != OK)
    return 1;
  return 0;
}

int(timer_display_conf)(uint8_t timer, uint8_t st, enum timer_status_field field) {

  union timer_status_field_val val;
  //unsigned char mode =  ( BIT(3) | BIT(2) | BIT(1) );

  switch (field) {

    case tsf_all:
      val.byte = st;
      break;

    case tsf_initial:
      //LSB mode
      if ((st & TIMER_LSB_MSB) == TIMER_LSB)
        val.in_mode = LSB_only;
      //MSB mode
      else if ((st & TIMER_LSB_MSB) == TIMER_MSB)
        val.in_mode = MSB_only;
      //MSB_after_LSB mode
      else if ((st & TIMER_LSB_MSB) == TIMER_LSB_MSB)
        val.in_mode = MSB_after_LSB;
      else
        val.in_mode = INVAL_val;
      break;

    case tsf_mode:
      //mode 0 (=000)
      if((st & BIT(2))==0)
        val.count_mode=0;
      //mode 1 (=001)
      if((st&BIT(1))==BIT(1))
        val.count_mode=1;
      //mode 2 (=010)
      if((st&BIT(2))==BIT(2))
        val.count_mode=2;
      //mode 3 (=011)
      if((st&(BIT(1)|BIT(2)))==(BIT(1)|BIT(2)))
        val.count_mode=3;
      //mode 4 (=100)
      if((st&BIT(3))==BIT(3))
        val.count_mode=4;
      //mode 5 (=101)
      if((st&(BIT(1)|BIT(3)))==(BIT(1)|BIT(3)))
        val.count_mode=5;
      break;

    case tsf_base:
      val.bcd=st&TIMER_BCD;
      break;

    default:
      break;
  }
  timer_print_config(timer, field, val);
  return 0;

}
